\subsection{Spectre attack as covert channel}
Original code had both attacker and victim in the same process. We separated them both into different processes while retaining shared memory. Instead of \texttt{array2}, which acted as shared memory in the original proof of concept code, we mapped a file to both processes. This file now acts as shared memory, having the exact same functionality of \texttt{array2}. \\
\indent Both attacker and victim are forked and execed by a parent process. Both processes need to be mapped to the same core of the CPU for this attack to work as we are detecting the secret data by measuring its latency of access. In the victim process, \texttt{array2} points to the mapped file. In the attacker process, \texttt{array2} points to the same mapped file. Thus we can use the memory of the file as shared memory to probe for lines which are brought into cache speculatively.

\subsection{Spectre on unshared memory}
We modelled spectre attack on unshared memory by keeping attacker and victim in same process. Attacker and victim do not access each other's data structures. Attacker first primes the cache by accessing a certain number of linked list nodes. Then attacker calls the victim function with valid input. Then attacker probes the cache by accessing the same linked list nodes. This is done repeatedly to mistrain the branch predictor. Then on the last iteration, attacker calls the victim function with invalid input. This causes the branch predictor to mispredict and speculatively execute the \texttt{if} statement. Attacker then probes the cache to see which cache lines have been accesses by the victim. \\
\indent Prime and probe is done on L1D cache here. This is possible due to the fact that attacker and victim reside in the same process. 

\subsection{Spectre on unshared memory - multiple processes}
We tried separating attacker and victim into two different process while not having any memory shared. Method is same as described before. Attacker primes the cache, then calls the victim function and then probes the cache to find the lines accessed by victim. We also mapped both the processes to the same core. But this attack was not successful.